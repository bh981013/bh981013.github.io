---
title: "2.process and thread"
tags: 
    - CS
    - OS
    - project
    - operating system
categories: 
    - OS
comments: true
---

# 프로세스란

프로세스라는 말은 한번 쯤 들어봤을 것이다. 프로세스는 실행중인 프로그램을 의미한다. 사실 운영체제 내부에서는 프로세스를 __특정 자료구조__ 로 관리한다. 즉, 그 실체는 어떤 자료구조 인 것이다.<br/><br/>

프로세스는 다음과 같은 것들을 가지고 있다.

- text section: 프로그램이 실행되는 코드이다. 우리가 코드를 작성하면, 그 코드가 text section이 되는 것이다.

- stack: 프로그램이 실행되면, 함수 호출, 지역변수 등이 stack에 추가된다.

- data: 전역변수들이 여기에 포함된다.

- heap: 동적으로 할당한 메모리가 이 부분에 포함된다.

- register: 프로그램이 실행되면, 그 과정에서 필요한 값들은 레지스터에 저장된다. 레지스터는 쉽게 말해 CPU내부의, 가장 빠르면서 매우 작은 메모리이다.


![image](https://bh981013.github.io/images/2022-02-15/02-15-OS1.jpg)

이것은 프로세스를 설명하는 아주 유명한 그림이다. 이것이 프로세스가 실행될 때 메모리의 구조라고 할 수 있다. 이 구조는 매우 중요하니까 꼭!! 알아두자!!

# 프로세스의 상태

프로세스는 생성부터 종료까지 여러 상태를 갖는다. 그 상태들에 대해서 알아보자.

- new: 프로세스가 막 생성되고 나서의 상태이다(태어났다!)

- running: 현재 프로세스의 명령어(insturction)가 실행되고 있는 상태이다.(유후~ 바로 이거지!)

- waiting: 프로세스가 어떤 이벤트가 일어나기를 기다리고 있는 상태이다.(난 아직 때가 아니야...)

- ready: OS가 프로세스를 runnning상태로 바꿔주기를 기다리고 있는 상태이다.(난 준비됐어!! 빨리 날 시작시켜줘!)

- terminated: 프로세스가 실행이 끝난 상태이다.(난 이제 간다~)

# 프로세스 자료구조

아까 프로세스의 실체는 특정 자료구조라고 하였다. 이 특정 자료구조가 바로 __PCB(process control block)__ 이다.<br/><br/>

PCB는 여러 정보들을 담고 있다. 프로세스의 상태(new, running, waiting.. 등등), PC(Program Counter의 약자로, 프로세스가 현재 실행중인 코드부분의 위치를 담는다), 레지스터 등등의 정보를 가지고 있다.<br/><br/>

현재 실행중인 프로세스에서 다른 프로세스로 변경하고 싶다면, PCB를 바꿔주면 되는 것이다.

# 스케줄러

우리는 보통 여러 프로세스를 동시에 실행시킨다. 예를들어 내가 유튜브를 보고있는 상태에서 카카오톡을 하려고 할때, 유튜브가 꺼지면 매우 불편할 것이다. 하지만 CPU의 코어가 하나라는 가정하에, CPU는 한번에 하나의 instruction만 실행 할 수 있다. 즉, 한번에 하나의 프로세스만 실행할 수 있는 것인데, 왜 우리 눈에는 여러가지를 한번에 실행하는것처럼 보일까?<br/><br/>


## Context switch

바로 CPU는 프로세스를 끊임없이 바꿔가며 실행시키기 때문에, 또 그 주기가 매우 짧기 때문에, 우리가 느끼기엔 여러 프로세스들이 동시에 실행시키는 것처럼 보인다. 이처럼 프로세스를 바꾸는 것을 __context switch__ 라고 부른다. 맥락을 바꾸는것이다. context switch를 담당하는 것이 바로 __스케줄러__ 이다. 여러 스케줄러가 프로세스의 상태(아까 설명한 running, waiting 등)을 바꿔가며 프로세스를 종료시키거나, 여러 프로세스를 동시에 실행시키는 것처럼 보이게 하는 것이다.<br/><br/>
그럼 context switch는 장점만 있을까? 단점들도 존재한다.
<br/><br/>

1. 프로세스를 변경하는 것 자체에 오버헤드가 발생한다. OS는 스위칭이 일어나는 순간 다른 일을 할수 없게 되기 때문이다.

2. 프로세스가 바뀌기 때문에, 접근하려는 메모리의 위치도 바뀌어 캐쉬 미스가 발생할 가능성이 높아진다.

그럼에도 장점이 훨신 많기 때문에, Context switch를 사용해서 여러 프로세스를 번갈아 가며 실행시킨다.
<br/><br/>

그럼 프로세스의 상태를 바꾸는 여러 스케줄러에 대해 알아보자.

## short term scheduler

말 그대로, 짧은 시간에 일어나는 스케줄러이다. 그만큼 빈번하게 일어난다. 우리가 인식하지 못할만큼 빈번하게 일어나는데, 이 스케줄러가 __프로세스를 ready queue에서 running queue로 바꾸는 역할__ 을 수행한다. CPU scheduler라고도 한다.

## long term scheduler

현재 OS가 ready queue에 넣을 프로세스를 결정하는 스케줄러이다. 프로세스를 새로 실행시키는 것은 프로세스를 바꾸는 횟수보단 현저하게 적게 일어나기 때문에, long term scheduler라고 하는 것이다. 

# Thread


## Thread란?

프로세스는 각각이 자신의 코드, 레지스터 등을 갖게된다. 하지만 같은 작업을 하는 여러 프로세스가 만들어지면, 코드가 같음에도 불구하고 메모리를 각자 차지하기 때문에 메모리의 낭비가 발생한다. 이때 사용할 수 있는 것이 __쓰레드(Thread)__ 이다. 쓰레드란 무엇일까?

- 프로세스의 __가벼은 버전__ 이다.

- CPU가 자원을 사용하는 최소 단위이다.

- 단독의 레지스터 값과 스택을 사용한다.

- 한 프로세스에서 실행된 쓰레드들은, 코드, 데이터, 자원들을 공유한다.

그럼 쓰레드를 사용하면 무슨 장점이 있을까?

## Thread의 장점

- 하나의 쓰레드가 멈추거나 오류가 발생해도, 다른 쓰레드는 각각의 레지스터, PC, 스택이 존재하기 때문에 정상적으로 실행될 수 있다.

- 자원을 공유하기 때문에, 하나의 자원에 여러 작업을 수행할 수 있다.

- 코어가 여러개인 CPU인 경우, 하나의 프로세스가 각각의 쓰레드로 나뉘어 여러 코어에서 동시에 실행될 수 있다.

- 코드부분이 공유되기 때문에, 경제적이다.

## 끝으로

이렇게 프로세스와 쓰레드에 대해서 알아봤다. 평소 헷갈리던 내용을 정리했으니, 앞으로는 헷갈리지 않겠지?







