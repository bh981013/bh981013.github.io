---
title: "4.CPU scheduler"
tags: 
    - CS
    - OS
    - project
    - operating system
categories: 
    - OS
comments: true
---

# CPU scheduling이란

CPU는 메모리에 존재하는 프로세스 중, ready queue에 존재하는 프로세스를 선택한 후 CPU자원을 할당하게 된다.<br/><br/>

이렇게 여러 프로세스 중 CPU에 어떤 프로세스를 할당할 지를 결정하는 것은 매우 중요하다. 이 결정에 의해 CPU가 얼마나 효율적으로 프로세스를 실행하는 지 결정되기 때문이다.<br/><br/>

# CPU 스케줄링 알고리즘의 성능 평가 기준

## CPU utilization

해당 알고리즘이 CPU를 쉬지않고 사용하는가?

## Throughput

해당 알고리즘이 단위시간에 끝내는 프로세스 개수가 많은가?

## Turnaround time

프로세스가 시작하고 끝나는 데 걸리는 시간이 얼마난가?

## Waiting time

ready queue에서 기다리는 시간이 짧은가?

# CPU 스케줄링 알고리즘들

## FCFS

> 먼저 시작한 프로세스가 먼저 끝나는 알고리즘

- 가장 타당하고 합리적일 수 있음.
- 프로세스가 종료되기 전까지 OS가 강제적으로 실행을 정지키지 않음(비강제적)
- 단점으로는 __Convoy effect__ 가있다. 만약 실행시간이 정말 긴 프로세스가 먼저 스케줄링 되었다면, 실행시간이 짧은 프로세스는 억울하지만 오랜시간 기다려야 한다.

## SJF

> 실행시간이 가장 짧게 남은 프로세가 실행

- 비강제적인 방법과 강제적인 방법으로 나뉨
    - 비강제적: 더 짧은 프로세스가 스케줄링 되어도 실행중인 프로세스는 마저 실행함
    - 강제적: 더 짧은 프로세스가 스케줄링 될 때 만약 이미 실행중인 프로세스가 존재해도, 실행중인 프로세스를 멈추고 더 짧은 프로세스를 실행시킴 -> __SRTF__ 알고리즘

하지만 어떤 프로세스가 금방 끝날지 예측할 수 있나??

> 그동안의 경험을 토대로 프로세스 실행시간을 예측함!

그렇다면 실행시간이 긴 프로세스는, 영원히 실행될 수 없을 수도 있지 않나??

## Priority scheduling

이렇듯 프로세스들이 고정된 우선순위를 갖는 스케줄링 기법을 __Priority scheduling__ 이라고 한다.<br/><br/>

SJF 는 실행시간이 짧은 프로세스가 우선순위를 갖는 기법이므로, Priority scheduling의 한 종류로 볼 수 있다.<br/><br/>

하지만 이런 priority scheduling 기법은 치명적인 단점이 존재한다.<br/><br/>

바로 __Starvation__ 이라고 부르는 현상이다.<br/><br/>

> Starvation 이란, 우선순위가 낮은 프로세스는 영원히 실행되지 않는 현상이다.

이러한 현상을 극복하기 위한 대표적인 방법으로 __aging__ 이 있다.

> aging이란, 시간이 지날수록 우선순위를 높여줌으로써, 낮은 우선순위를 갖는 프로세스도 오랜시간동안 실행되지 못하면 우선순위가 높아짐으로써 실행될 수 있게 하는 것이다.


## Round robin

프로세스들에게 특정한 time quantum(시간 기준)을 두고, 그 기준을 넘도록 프로세스가 종료되지 않으면 자동으로 다음 프로세스가 실행되는 기법이다.<br/><br/>

각자 공평하게 실행할 수 있는 시간이 정해져 있는 것이다.<br/><br/>

이 알고리즘의 성능은 time quantum에 따라 달라진다.<br/><br/>

> time quantum 이 긴 경우: 모든 프로세스가 time quantum이 끝나기 전에 실행이 종료되므로, FCFS와 다를게 없게 된다.

> time quantum 이 짧은 경우: context switch에 들어가는 오버헤드가 너무 커진다.

## Multilevel queue

프로세스들이 각 성질에 따라서 다른 알고리즘이 사용될 필요가 있을 때가 있다.<br/><br/>

예를 들어, 사용자와 인터랙션이 많은 프로세스는 반응속도가 더 빨라야 하지만, 그렇지 않은 내부적인 프로세스는 조금 천천히 실행되도 큰 문제가 발생하지 않는다.<br/><br/>

그러한 프로세스의 성질을 반영하여 각각 다른 알고리즘을 가진 큐에 관리할 수 있다.<br/><br/>

이렇게 __여러개의 큐를 가지고 프로세스를 관리하는 것__ 을 MLQ라고 한다.<br/><br/>

MLQ 중요도가 높은 큐를 먼저 실행한 후, 그다음 중요도를 가진 큐를 실행할 수 있다.<br/><br/>

하지만 중요도를 가진 스케줄링의 단점인 Starvation이 역시 발생할 수 있으므로, 각 큐마다 time slice를 갖는 방식으로 해결할 수 있다.

## MLFQ

MLQ는 프로세스의 각 성질에 따라 맞는 알고리즘과 우선순위를 갖는 큐에 스케줄링 하는 알고리즘이다.<br/><br/>

> 하지만 어떻게 프로세스의 성질을 미리 안다는 것인가!!

만약 특정 큐에 들어간 프로세스가, 예상하던 성질을 갖고있지 않은 프로세스라면 문제가 발생할 것이다.<br/><br/>

이러한 문제를 해결한것이 __Multilevel feedback queue(MLFQ)__ 이다.<br/><br/>

> MLFQ란 여러 큐를 가진 스케줄링 알고리즘이지만, 프로세스들이 큐마다 이동할 수 있다.

# 끝으로

이렇게 여러 스케줄링 알고리즘에 대해 알아봤다. 면접에서 해당 질문을 받아서 한번 더 정리해보았다! 다들 화이팅~!


