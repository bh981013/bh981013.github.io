---
title: "4.Concurrency Control"
tags: 
    - CS
    - DBMS
    - project
    - b+tree
    - database
categories: 
    - DBMS
comments: true
---

# DB에 여러사람이 접근할 때 발생하는 문제

Database는 여러 사람들에게 의해 접근되고 변경된다. 이때 여러 문제가 발생할 수 있다.

## Lost update

> 내가 은행에 100만원을 넣었는데, 만약 우연히 같은 계좌에 우리 아빠가 용돈을 20만원을 넣어줬다면?

당연히 계좌에는 120만원이 있어야 한다. 하지만 아빠가 거의 동시에 계좌에 넣어서, 아빠는 0원에서 20만원으로 증가시켰으면 최종 값이 20만원으로 남게 될 수도 있다!<br/><br/>

이런 상황을 Lost update라고 한다. 내가 계좌에 돈을 넣은것은 무시된것이다..즉 __업데이트를 잃어버렸다(lost update)__ 고 볼 수 있다.<br/><br/>

## Inconsistent read

> 내가 우리 누나의 계좌에 100만원을 보내려고 한다. 내 계좌에서 100만원이 차감되고, 누나 계좌에서 100만원이 증가하려는 순간! 누군가 우리 가족 계좌의 총 금액을 확인하려고 한다면?

그 순간이 절묘하게 겹치면, 우리 가족 계좌의 총 금액을 더하는 과정에서 실제보다 100만원이 적게 계산될 수 있다.<br/><br/>

이것이 바로 Inconsistent read이다.

## Dirty read

> 내가 내 계좌에서 100만원을 출금하려고 하는데, 갑자기 오류가 떠서 출금이 안됐다. 이때 은행에서 내 계좌를 확인하려고 한다면?

오류가 발생해서 롤백이 일어날 때, 그 롤백이 반영되기 전 누군가 내 계좌를 확인하게 된다면, 잘못된 값을 확인하게 된다.<br/><br/>

이것을 dirty read, 즉 정확하지않은 __더러운 값을 확인(dirty read)__ 하는 것이다.<br/><br/>

# 어떻게 이 문제들을 해결할 까?

이렇듯 데이터베이스에 여러 사람이 접근하게 될 때 발생할 수 있는 문제들을 알아봤다.<br/><br/>

이러한 문제들을 해결하려면, 어떤 원칙들을 가져야 할까?<br/><br/>

## 트랜잭션(transaction, trx)

문제들을 해결하려면, 사용자로 하여금 이게 문제가 아니라는 걸 알려줄 __최소 단위__ 가 필요하다. 예를들어, 내가 영화를 예매할 때 좌석을 내가 골랐다고 해서 이 좌석을 내가 완전히 예약했다고 생각하지 않는다. 보통 __예약완료문자__ 혹은 __예약이 완료되었습니다__ 와 같은 안내를 보고, 내 예약이 성공적으로 진행되었다고 판단한다. 이렇듯 어떤 작업의 단위를 지칭할 떄 __transaction__ 이라고 한다. 하나의 transaction이 완료되면, <u>내가 원하는 일련의 작업들이 제대로 되었다는 것을 확신할 수 있는것</u>이고, 아무리 여러 작업을 해도 transaction이 끝나지 않았다면, 내가 했던 작업들이 날라가도 난 할말이 없는 것이다(예를 들어 내가 영화 좌석을 골랐는데, 예약 완료전에 누가 내 자리를 뺏어도 나는 할말이 없는것이다..!)<br/><br/>

그럼 우리가 정의한 트랜잭션이 지켜야 할 원칙들에는 어떤 것들이 있을까? 트랜잭션은 다음 네가지 원칙을 지켜야 한다. 그 4가지 원칙을 알아보자.

## 원칙 1. Atomicity

__원자성__ 이라고도 하는 Atomicity는, 트랜잭션은 __실행되거나, 실행되지 않거나__ 둘 중 하나의 상태만을 갖는다. All or nothing인 것이다. Trx를 구성하는 여러 작업들이 중간에 끊긴채로 DB에 남아있으면 안된다. Trx가 중간에 끊기면, 그동안 작업했던 것들은 다시 되돌려져야 하고, Trx가 종료되었으면 그동안 작업했던 것들은 DB에 반영되어야 한다.

## 원칙 2. Consistency

__일관성__ 이라고도 한다. DB의 어떤 원칙이나 조건이 Trx전 후로 변함이 없어야 한다. 이를 위반하는 trx는 수행되서는 안되는 것이다. 예를들어 integer값이 들어가야 하는 컬럼에, String을 넣는 operation이 포함된 trx는 수행되서는 안된다.

## 원칙 3. Isolation

__독립성__ 이라고도 한다. 각 trx는 독립적이어서, 한 trx가 수행할 때 다른 trx는 그 중간 과정을 확인할 수 없다.

## 원칙 4. Durability

__강건성__ 이다. trx의 결과가 db에 반영되면, 그 결과는 영구히 유지되어야 한다. DB에 문제가 생겨도, trx의 결과는 log에 반영되어 있어야 한다.
<br/><br/>

이렇게 트랜잭션이 지켜야할 원칙들에 대해 알아봤다. 그럼 어떠한 방법으로 이러한 원칙들을 보장할 수 있는지 알아보자.

# 동시성을 어떻게 제어할까

여러 trx의 작업이 문제가 없으러면 가장 좋은 방법이 무엇일까? 당연히 __한번에 하나의 trx만 수행__ 하게 하는 것, 즉 __trx를 연속적으로 수행하는 것__ 이다. 하지만 이 방법은 너무나 비효율적이다. 하나의 trx가 언제 끝날지 도 모르는데, 계속 기다릴수는 없는 것이다.<br/><br/>

그럼 어떤 방법이 있을까?

여기서 앞으로의 원활한 설명을 위해 간단하게 용어를 정리해보자.<br/><br/>

## 용어 정리

- Operation: Read, write과 수행하는 작업이다.

- Transaction/Trx: Operation들이 모여 독립성을 보장하는 최소 단위이다(지금까지 설명한 것). Operation들의 집합으로도 생각할 수 있다.

- Schedule(스케줄): 여러 Trx의 집합의 순서이다.

>이 용어를 정리한 이유는, 내가 헷갈려서 이다. 쉽게 생각해서 operation -> Trx -> Schedule 이라고 볼 수 있다.

- Serial schedule: 스케줄을 구성한 Trx들이 연속적이다. 즉 한번에 하나의 Trx가 수행되고, 하나의 trx가 시작되면 끝날때까지 다른 trx는 전부 기다린다.(우리가 말한 동시성을 제어하는 가장 쉽고, 가장 비효율적인 방법이다)


## Serializable Scheudule

>trx를 연속적으로 수행시키는 것이 매우 비효율적이라고 했다. 그럼 trx를 연속적인 것과 같은 결과를 내도록 trx를 배치하는 것은 어떨까? 결국 결과적으로 같으니까, 전혀 상관없을 것이다.

어떤 스케줄이 있는 데, 이 스케줄은 여러개의 trx가 동시에 실행되는데, 그 결과를 보니까, trx가 한번에 하나씩 연속적으로 수행될 때랑 다를바가 없는 것이다!(완전 이득!)<br/><br/>

그럼 그러한 스케줄은 Trx가 연속적이게 바꿀 수 있으므로, Serialzable schedule이라고 한다.

## Conflict Serializable Schedule

여기서부터 난 용어가 참 혼란스러웠다... 이 용어를 이해하려면 우선 Confict한것이 무엇인지 이해해야 한다. 

- Conflict: 서로 다른 트랜잭션이 같은 데이터에 접근할 때, 적어도 하나가 변경하는 작업이면 두 작업은 conflict하다고 한다.

즉, Conflict한 연산은 순서를 바꿔버리면, 다른 결과가 나올 가능성이 매우 높다. <br/><br/>

이게 왜 중요하나면, 우리는 결국 Trx의 Schedule을 조정해서 가장 효율적이고 문제없는 결과를 도출해야 한다. 그러기 위해 가장 좋은 방법은 Schedule내의 trx를 연속적이게 바꾸는 것이다!(이건 지금까지 계속 설명한 것임!). 근데 Conflict한 operation의 순서를 바꾸면서까지 연속적으로 만들어 버리면, 그건 아예 다른 결과를 도출할 수 있기 때문에. 그래선 절대 안된다.
은행 계좌를 나는 조회하고, 아빠는 입금을 하는데, 그 순서가 바뀌어 아빠가 입금하고, 난 조회하게 되면 두 작업에서 각각의 사람이 계좌를 확인하는 결과는 다를 수 밖에 없을 것이다. 

> 그래서 중요한 건, __Trx의 스케줄을 조정하는데, conflict한 연산의 순서는 바꾸지 않는 상태로 연속적이게(serializable) 바꿀수 있냐?__ 인 것이다. 

위 대답에 네! 라고 할 수 있는 스케줄을 Conflict Serialzable Schedule이라고 하는 것이다!

> 이 용어를 이해하기는 상당히 힘들 수 있다(내가 그랬음..!). 너무 낙심하지 말고 천천히 정의를 곱씹어보면서 차근차근 생각해보자.


# 중간정리

> 하나의 데이터에 여러 트랜잭션이 동시에 접근하게 되면 문제가 발생할 수 있다.

> 그러한 문제를 해결하기 가장 좋은 방법은, 한번에 하나의 트랜잭션만 수행하고, 다른 트랜잭션이 끝나면 다음 트랜잭션을 __연속적으로 수행__ 시킨다

> 하지만 동시에 실행시켜도, 연속적으로 수행시키는 것과 같은 결과를 낼 수 있다면, 그 스케줄은 정상적으로 수행될 수 있다.

# 동시성 제어 기법들

그럼 이제 동시성 제어를 위한 대표적인 방법인 2PL에 대해 알아보자.

## lock

우선 lock이 무엇인지 알아야 한다. lock은 권한이라고 볼 수 있다. 어떤 데이터에 작업을 수행하기 위해서는, 그 작업을 수행할 수 있는 권한이 필요하다. 만약 다른 사람(혹은 트랜잭션)이 그 권한을 가지고 있으면, 권한을 넘겨줄때 까지 기다리고 있어야 한다.

## Shared lock, Exclusive lock

그럼 lock을 획득한 후 데이터에 접근할 수 있는데, 조금 더 효율적으로 생각해볼 수 없을까? <br/><br/>

사실 어떤 데이터를 변화시키려 하지 않고 오직 읽으려고만 한다면, 여러 트랜잭션이 동시에 데이터에 접근해도 문제가 없다. 문제는 누군가 변경하려고 할 때이다.<br/><br/>

여기서 나온 아이디어가 S lock, X lock (shared lock, exclusive lock)이다. S lock은 동시에 여러 트랜잭션이 획득 할 수 있지만, X lock은 오직 하나의 트랜잭션만이 획득 할 수 있다.

## 2PL locking 기법

2PL은 two phase locking의 줄임말이다. 2PL의 몇가지 원칙들을 알아보자.

1. 트랜잭션은 데이터를 읽기 위해서 S lock을, 쓰기 위해서는 X lock을 획득해야 한다.

    이건 이미 설명한 내용이므로, 설명은 생략하겠다.

2. 트랜잭션은 __lock을 해제하기 시직하면, 더이상 lock을 얻을 수 없다__

    이 2번쨰 원칙이 이 기법이 2PL이라고 불리는 이유이다. 2PL기법에서 트랜잭션은 획득과정(Aquisition phase)와 해제과정(release phase)의 두가지 phase를 갖고 있기 때문에 two phase locking이라고 불리는 것이다.

- 2PL 기법이 conflict serializability를 보장하는 이유

    이 기법에서 트랜잭션은 lock을 해제하는 순간은 이미 모든 작업이 끝났을 때이다. 즉 이 트랜잭션과 conflict한 operation을 가진 트랜잭션들은 __1) lock을 획득하려고 기다리고 있거나__, __2) lock을 전부 획득한 후 현재 lock을 해제하고 있거나__ 이다. 따라서 conflict한 operation의 순서는 lock으로 인해서 유지될 수 밖에 없는 것이다. 


- 2PL의 단점

    2PL 기법은 lock을 하나 씩 해제한다. 즉, 내가 아직 trx 작업이 끝나지 않았더라도, 내가 중간에 lock을 해제하여 다른 누군가가 해당 데이터에 접근할 수 있는 것이다.<br/><br/>

    이런 상황에서, 만약 내가 작업을 중간에 롤백시킨다면? 그럼 내가 변경헀던 모든 값들을 다시 원래대로 돌려놔야 한다.<br/><br/>

    하지만 만약 그 사이에 누군가 해당 데이터에 접근했다면, 그 사람은 내가 다시 되돌릴 데이터에 접근했기 때문에, 그 사람의 작업도 다시 롤백되어야 한다.<br/><br/>

    이렇듯 2PL은 연쇄적으로 롤백이 발생할 수 있는데, 이를 __cacading abort__ 라고 한다(abort 라는 단어를 기억하자. 앞으로 자주 쓰게 될 단어이다).
    <br/><br/>

## strict 2PL

이러한 단점을 극복하기 위해 나온 방법이 strict 2PL이다. strict 2PL은 기존의 2PL방식과 대부분 유사하지만, 다른점은 한가지이다. 바로 __트랜잭션이 가지고 있는 모든 lock을 한번에 해제한다는 것이다.__ 이렇게 되면, 내가 아직 작업이 끝나지 않은 상태에서 누군가 내가 수정한 데이터에 접근할 일이 없다. 왜냐면, 누군가 내가 수정한 데이터에 접근할 수 있다는 것은, 내가 이미 모든 lock을 해제하고 작업을 끝냈다는 것이기 때문이다.

# 여전히 남은 단점

이렇게 2PL, strict 2PL에 대해 알아봤다. 하지만 여전히 해결해야 할 문제가 남아있다. 바로 deadlock문제이다. 2PL과 strict 2PL 모두 deadlock이 발생할 가능성이 남아있다. 이 문제는 어떻게 해결할지 다음 게시물에서 알아보자.

# 끝으로

트랜잭션과 동시성 제어 방법에 대해 알아봤다. 이 개념은 상당히 어렵고 복잡하다고 느꼈다. 아직도 많은 복습이 필요하다고 느낀다. 




